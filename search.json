[{"title":"基于图像模糊和光吸收的水下图像恢复","url":"/jiangkeer-art.github.io/2022/04/14/基于图像模糊和光吸收的水下图像恢复/","content":"# 基于图像模糊和光吸收的水下图像恢复\n最近研究了一些关于水下图像去雾恢复的东西，虽然没有写出来什么，但是读到了一些论文，这里写一下论文的研究过程以及原理之类的，论文是Underwater Image Restoration Based on Image Blurriness and Light Absorption，在IEEE上找的。\n<!-- more -->\n## 首先是原理解释\n![](http://cnd.jiangkeer.icu/image_0_2_0.jpg)\n\n上图中a表述了简化的水下场景成像的模型(IFM)，其中的I(X)指的是在像素x处观察到的强度，由透射图TM t(x)与背景光(BL) B混合场景辐射J(x)组成。TM描述了未散射或被吸收并且到达相机的场景辐射。下面的五张图片显示了具有不同背景光(BL)的五个水下图像。\n\n## 具体实现流程\n首先从水下图像中的模糊区域中选择BL，然后基于BL获得深度图和TM用来恢复场景辐射。\n\n### 图像模糊估计\n模糊估计共有三个步骤，首先是进行初始模糊图Pinit的计算，公式在下面：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX411.jpg)\n其中Ig是输入图像Ic的灰度版本，ri=2i*n+1，并且n为4，接下来使用最大滤波器来计算粗糙模糊度图Pr：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX412.jpg)\n其中![](http://cnd.jiangkeer.icu/INNERLATEXT411.jpg)是以x为中心的z*z局部补丁，设置z为7，随后使用soft matting来平滑生成一个模糊图像Pblr：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX414.jpg)\n其中Cr是填充孔的形态重建算子，Fg是soft matting。\n\n### 背景光估计\n有了图像模糊之后就是背景光估计(BL)，BL确定水下图像的色调以及其恢复的场景辐射。下面是基于图像模糊和方差来估计BL的算法：\n![](http://cnd.jiangkeer.icu/linetable_5_1_0.jpg)\n其从输入图像中的前0.1％模糊像素，最低方差区域和最大模糊区域中选取三个BL候选。使用四叉树分解来确定这两个区域（可以相同或不同），根据方差或模糊度将输入图像迭代地划分为四个相等大小的块。通过对模糊图中的对应区域中的Pblr（x）求平均来获得输入图像中的区域的模糊性。确定了三个BL候选者后，我们根据输入图像分别为每个颜色通道选择BL。\n\n### 基于光吸收和图像模糊的深度估计\n这里使用了三种深度估计的方法进行估计场景深度，随后将三种方法进行组合，得到最后的场景深度。\n#### 首先是第一的方法，直接通过红色通道图获得第一次深度估计\n下面是红色通道图R的定义：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX520.jpg)\n随后进行深度估计：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX521.jpg)\n其中Fs是拉伸函数：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX522.jpg)\nV是向量。\n#### 随后是第二次深度估计\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX523.jpg)\n使用Eq和Fs与Dmip进行估计，下面是Dmip的计算方法。\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX210.jpg)\n#### 第三次深度估计\n使用方程式中的图像模糊度Pr进行深度估计。\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX524.jpg)\n\n### TM估计和场景辐射恢复\n首先是根据公式计算TM：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX128.jpg)\n它使用从摄像机到场景点的深度，为了测量从摄像机到每个场景点的距离，还必须估计最近的场景点和摄像机之间的距离d0：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX620.jpg)\n结合Eq，最终场景深度为：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX621.jpg)\n其中D是用于将相对距离转换为实际距离的缩放常数。\n使用~df，我们可以将红色通道的TM计算为：\n![](http://cnd.jiangkeer.icu/PARAGRAPHLATEX622.jpg)\n","tags":["python","图像增强"],"categories":["图像增强","python"]},{"title":"小说大纲？","url":"/jiangkeer-art.github.io/2022/01/05/小说大纲？/","content":"\n要是想写好一点就需要一个大纲，但是我其实也没写过什么大纲，这里也相当于是练一练手吧，主要写的应该是小说故事的各种设定之类的。\n\n<!-- more -->\n\n## 第一章：\n\n第一章主要讲了主角遇到了他的师傅恶灵，恶灵将主角拉到了一个没有给出的空间进行各种战斗训练（包括枪械射击，手雷等投掷物，以及近身格斗技巧和恶灵的传送门如何使用），主角和恶灵相处了很长的时间，在最后一次训练之后主角已经变成了恶灵的继承人，随后就是突如其来的参加比赛。\n\n## 第二章：\n\n第二章从天空中下落开始讲起，随后主角使用传送门穿送到了一栋大楼的楼顶，随后在楼顶观察情况。这里可以补充一下设定，就是比赛的内容，比赛内容为无，想了想，还是觉得无最合适了，既然不知道比赛内容设定为什么东西比较好的话就不要设置了，然后是在穿过传送门之后的世界里面的一些设定，首先是主角变成了女生，左手手臂上有一个手环，类似于小米手环那种，外貌较为瘦弱，但是身体素质极高，随后地点参照大连海事大学进行描述，随后就是安排见到人物了，首先见到的是见到了幻象的分身，随后是","tags":["小说","大纲"],"categories":["小说","作为日记加密"]},{"title":"小说2","url":"/jiangkeer-art.github.io/2022/01/05/小说2/","content":"\n## 序言2\n这章应该会正式确定出比赛内容，也就是之后最主要要讲的事情，但是具体是什么，我自己也不清楚。XD\n\n<!-- more -->\n\n## 第二章\n\n","tags":["小说"],"categories":["小说"]},{"title":"小说","url":"/jiangkeer-art.github.io/2021/11/06/小说/","content":"\n# 随便写写的小说\n\n\n## 算是序言吧\n\n最近没什么想做的事情，所以来写写小说，严格来说要写的应该是剧本，但是我的水平感觉些什么都差不多，所以就叫什么应该都无所谓了（如果你想读的话最好不要有什么期望）。\n<!-- more -->\n## 第一章\n\n今天天气很好，风和日丽，阳光透过窗户洒在我的床上。虽说今天的太阳是挺大的，但是阳光透过窗户洒在我的房间，也只能照亮房间的一部分，我的桌子所在的位置还是布满阴影，虽然也不是特别暗吧，但我还是喜欢把窗帘拉上。房间的窗帘是竹子做的那种，即使拉上也不至于让整个房间黑掉，总有些倔强的阳光会通过窗帘上的缝隙进入我的房间，而我就喜欢这样的阳光，它们义无反顾的进来，然后点亮我的房间，每次看到这样的景象，就会有一种难以言表的情绪，怎么说呢，有些消极，也有些温暖。\n\n将窗帘拉上并且把门也关上之后，我要开始我的无意义之旅了。打开电脑，登陆企鹅，进入我的游戏群，直接就是一句@全体成员 上号！随后打开我的apex，开始等待好兄弟们上线。\n\n我挺宅的，喜欢玩游戏，玩什么看心情，想玩什么就玩什么，虽然是挺没意义的吧，但是这毕竟是消磨时光的有效方式，每次我想要打发时间的时候就会玩游戏，也总比没事干强。\n\n没过多久群友就来了，“喂喂喂，听得到吗？”，“可以”。我简单的回了一句，随后马上开始了游戏。\n\n好久不玩机器人了，来一把。伴随着“快要听吐了”的背景音乐，我选出了我心爱的机器人，并且开始准备进入游戏里“大杀四方”。\n\n“又玩机器人啊，你还真是不腻。”\n\n“还行把，感觉别的角色也没啥好玩的。”\n\n随后，我选择的机器人在我的眼中逐渐放大，逐渐大出了屏幕，随后一个虚空传送门出现在了我的面前，门的形状是个椭圆形，从边缘的浅蓝色到中心的黑色渐变，并且伴随着波浪般的律动和一些电流，随后门中伸出一只手，把我拉了进去。\n\n“你就不能在之前提示我以下吗？”\n\n尽管已经经历过了几次，但还是有点不适应，尤其是在虚空中的感觉，就像是有个压路机在碾你的身体一样，但是身体是悬空的，那种异样的感觉我到现在还是适应不了。\n\n恶灵:“别叫，干活。”\n\n当我第一次玩apex的时候，恶灵就出现了，毋庸置疑，大概可以用屁滚尿流来形容吧，我当时的反应。但是她可不管我什么反应，不管三七二十一直接就把我扔进了传送门里。\n\n恢复意识的时候我躺在哈德曼实验室的传送门附近，在我身边的还有当时把我带入传送门的恶灵，她当时跟我聊了很多，这也是她说话最多的一次了，我已经记不清楚当时她说的是什么了，但是大概意思还是了解的，就是我要参加一个比赛，她没给我选择的机会，只说了会教我如何训练，也没有说我的队友是谁，也没说我是怎么来的，并且我也注意到我的身体有了一些变化，当我进入传送门之后，我的身体就会出现很多恶灵的身体特征，怎么说呢，变化还是很大的，以至于我一开始以为我变成恶灵的样子了，是的，如果想进入这个地方，所容纳自己意识的角色是要与游戏中的角色相差不大的，所以会出现这样的情况，简单来说就是我的身体不能适应这里的环境，恶灵就给我找了一个在这里用的身体，但是身体是怎么来的，我是怎么进入的，是不是有别人也和我有一样的经历，我都不知道。\n\n经过了短暂的回忆，我开始做我不得不做的事情，训练，内容包括但不限于格斗，射击，虚空传送门的使用等等，每次训练要一整天，但是奇怪的是，当我回到我的房间时，时间才过去了2，3个小时，我问过恶灵，但是没得到答复。\n\n训练结束后，我坐在地上看着天上的飞龙发呆。\n\n“过两天，时间就到了。”\n\n“啊,为什么这么快啊？”我将视线从飞龙转向恶灵。\n\n“他们把时间提前了，是生是死，就看你自己了。”\n\n这件事情很离谱，但是我也不敢问，因为就算是问了大概率也是没有什么回复的，要是真的要参加那个什么比赛，就只好听天由命了，毕竟恶灵这样的人都出现了，那再出现一些离谱的事情也不是不可能吧，想逃估计也是逃不走的。\n\n“时间差不多了，走吧，下次就没有人来接你了。“\n\n”为啥，下次就是参赛了吗？”\n\n“是，到时候你就知道了。”\n\nsteam中的记录显示我游玩apex的时间已经有500多个小时了，但是实际上我的apex水平还处在走路都走不明白的水平，大部分时间都是被恶灵拉去做那些痛苦又枯燥的训练。虽然试过不玩apex，想着能逃过一劫，或者是说服自己看到的都是幻觉，但是就算是不玩，恶灵也会找上门来，然后冷冰冰地开始监督我训练。不过我也算是学会了怎么用传送门吧，虽然我只能在恶灵把我拉进来的这个空间里面使用传送门，但是我可以把传送门开到自己的房间里。\n\n从传送门走出来后，我又坐在了电脑面前，带上耳机，屏幕显示现在时间时6点整，耳边传来开黑朋友的声音，“我要出门，先下了。”，“那我也下了，吃饭去了。”\n\n未等我回复，老妈就将我的耳机摘了下来，“叫你咋听不见啊，快去外面买点鸡蛋回来，家里没鸡蛋了。”\n\n“好好好，马上就去。”\n\n我觉得我最近也有点像恶灵了，在沉默寡言方面。\n\n简单的披上了一件羽绒服之后我就出门（对没错，穿着睡衣）去买鸡蛋，但是就在打开门的一瞬间，我仿佛是听到了电网被隔断的声音，手中的动作瞬间停了下来，随后通过门缝朝外观察。\n\n并没有什么异常的情况发生，随后我又将门关上再打开，看看是不是自己听错了。\n\n应该是听错了吧，最近训练的频率很高。\n\n确认了刚才的声音是幻觉之后，我稍显发抖的身子也逐渐趋于稳定。\n\n随后的这两天里，没再发生这样的事情，一切都挺正常的，至少在我眼中很正常吧。但是时间一点点流失，我也没有等到参赛的通知。\n\n我躺在床上，思考着我会怎么参加比赛。\n\n不是没有人来接我吗？那只能是我自己去参加，可是我也不知道什么时候去，去什么地方阿。\n\n一阵坠落（zhui）的感觉将我的思绪拉了回来，随后眼中熟悉的天花板快速的缩小，我意识到自己进入传送门了。\n\n不同的是，这次的传送门还能看到我房间内的景象，房间内的灯光可以透过传送门照到我的脸上。这不是恶灵和我平时用的传送门，但是现在来不及想这些了，身体传给我的感觉和不断缩小到和天空中的星星融为一体的传送门都在告诉我，我在下坠。","tags":["小说"],"categories":["小说"]},{"title":"MIT6.S081 Lab1","url":"/jiangkeer-art.github.io/2021/10/27/MIT6-S081Lab1/","content":"# MIT6.S081 Lab1实验代码\n\n\n## Sleep(Easy)\n\n第一个实验的要求是实现sleep函数，函数放在user目录下。查看提示中说的程序例如echo.c，可以看到主函数有两个参数，分别为int型的argc和char*型的argv，这两个参数的作用是传递用户从命令行中输入的指令，argc为单词的个数，argv则是存储输入的命令。\n<!-- more -->\n\n提示中说明了可以使用artoi将char型转化为int型，并且给出了sleep的系统调用，所以实现起来就比较简单了。\n```\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint\nmain(int argc, char *argv[])\n{\n\tif(argc!=2){\n\t\tfprintf(2,\"erro!\\n\");\n\t\texit(1);\n\t}\n\tsleep(atoi(argv[1]));\n\texit(0);\n}\n```\n\n因为sleep指令只需要两个字符，所以判断argc是不是2，如果不是就输出错误，并且退出程序，总体来说这个代码还是简单的。\n\n```\n./grade-lab-util sleep\n```\n\n在项目目录下面输入上面的指令可以查看自己写的代码是不是过关了，在输入之前不要忘记在Makefile文件中添加自己的sleep，如何添加在提示中已经说明了。\n\n下面是运行结果\n\n![](http://cnd.jiangkeer.icu/MITLab1-sleep.png)\n\n## Pingpong(Easy)\n\n这个实验的要求是子进程向父进程发送一个字节，父进程收到之后打印规定的输出，然后父进程也向子进程发送一个字节，子进收到之后打印规定的输出，两个进程传输字节使用的是两个不同的管道，这个实验也不算难。\n```\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nint\nmain(int argc, char *argv[]){\n\tint p1[2],p2[2],pid;\n\tpipe(p1);\n\tpipe(p2);\n\tchar buf2[8];\n\twhile((pid=fork())==-1);\n\tif(pid==0){\n\t\tclose(p1[0]);\n\t\tclose(p2[1]);\n\t\twrite(p1[1],\"a\",1);\n\t\tread(p2[0],buf2,8);\n\t\tprintf(\"%d: received ping\\n\",getpid());\n\t\texit(0);\n\t}\n\telse{\n\t\tclose(p1[1]);\n\t\tclose(p2[0]);\n\t\twrite(p2[1],\"b\",1);\n\t\tread(p1[0],buf2,8);\n\t\twait(0);\n\t\tprintf(\"%d: received pong\\n\",getpid());\n\t}\n\texit(0);\n}\n```\n\n这里说明一下close的用法的，close可以将输入端和输出端关闭，close(p1[1])就是将写端关闭，这里有一点需要注意以下，close关闭的管道是在进程中关闭，close在哪个进程就关闭哪个进程的读端或写端，但是别的进程是不受影响。\n\n```\n./grade-lab-util pingpong\n```\n\n同样的，输入这段指令检查代码有没有问题。\n\n![avator](http://cnd.jiangkeer.icu/find.png)\n\n## Primes(Moderate)\n\n下面是利用管道来筛选素数，实验上说的算法简单来讲就是子进程读取父进程传来的数据，然后和自己的数字进行比较，如果能整除就说明不是素数，如果不能被整除就将他传递给子进程的子进程进行判断。\n\n还有一点就是，子进程收到的第一个数字一定是一个素数，因为如果某个子进程是第一次收到数字的话，就证明这个数字通过了之前进程的验证，所以他一定是一个素数。\n\n在当前进程收到第一个数字之后，就会把这个数字当成是自己的数字，然后接着接收别的进程发来的数字，并和自己的数字进行比较，如果不能被整除，就发送到下一个进程。\n\n```\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n\nvoid\ncreatefork(int p[2]){\n\tclose(p[1]);\n\tint pid,n2,n3;\n\tif(read(p[0],&n2,sizeof(n2))){\n\t\tprintf(\"prime %d\\n\",n2);\n\t\tint p1[2];\n\t\tpipe(p1);\n\t\tpid=fork();\n\t\tif(pid>0){\n\t\t\tclose(p1[0]);\n\t\t\twhile(read(p[0],&n3,sizeof(n3))){\n\t\t\t\tif(n3%n2!=0){\n\t\t\t\t\twrite(p1[1],&n3,sizeof(n3));\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(p1[1]);\n\t\t\twait(0);\n\t\t}else{\n\t\t\tclose(p[0]);\n\t\t\tcreatefork(p1);\n\t\t}\n\t}\n}\n\nint\nmain(int argc,char *argv[]){\n\tint p[2],pid,n1;\n\tpipe(p);\n\tpid=fork();\n\tif(pid==0){\n\t\tcreatefork(p);\n\t}\n\telse{\n\t\tclose(p[0]);\n\t\tfor(n1=2;n1<=35;n1++){\n\t\t\twrite(p[1],&n1,sizeof(n1));\n\t\t}\n\t\tclose(p[1]);\n\t\twait(0);\n\t}\n\texit(0);\n}\n```\n\n因为在提示中说明了进程达到35的时候会导致xv6系统资源不足，所以在传输数字的时候只要传输35个就可以了，也就是1到35，并且要把用不到的管道及时关闭。\n\n实现的方法采用的是递归实现，统一由父进程实现具体操作，子进程进行递归，代码的原理与一开始说的一样，这里不需要考虑读写的顺序，以及不同的子进程要读取几个数字，查看read的返回值就可以了，如果read读取成功了会返回1，所以可以把read放到判断条件里，这样如果read读取失败了就不会继续往下执行了。\n\n## find(moderate)\n\n实验这里要让我们做一个简单的find指令，具体的操作让我们看user下的ls.c，那首先就要看懂ls.c的代码（实际上看不太懂没关系）。\n\n```\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nchar*\nfmtname(char *path)\n{\n  static char buf[DIRSIZ+1];\n  char *p;\n\n  // Find first character after last slash.\n  for(p=path+strlen(path); p >= path && *p != '/'; p--)\n    ;\n  p++;\n\n  // Return blank-padded name.\n  if(strlen(p) >= DIRSIZ)\n    return p;\n  memmove(buf, p, strlen(p));\n  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));\n  return buf;\n}\n\nvoid\nls(char *path)\n{\n  char buf[512], *p;\n  int fd;\n  struct dirent de;\n  struct stat st;\n\n  if((fd = open(path, 0)) < 0){\n    fprintf(2, \"ls: cannot open %s\\n\", path);\n    return;\n  }\n\n  if(fstat(fd, &st) < 0){\n    fprintf(2, \"ls: cannot stat %s\\n\", path);\n    close(fd);\n    return;\n  }\n\n  switch(st.type){\n  case T_FILE:\n    printf(\"%s %d %d %l\\n\", fmtname(path), st.type, st.ino, st.size);\n    break;\n\n  case T_DIR:\n    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){\n      printf(\"ls: path too long\\n\");\n      break;\n    }\n    strcpy(buf, path);\n    p = buf+strlen(buf);\n    *p++ = '/';\n    while(read(fd, &de, sizeof(de)) == sizeof(de)){\n      if(de.inum == 0)\n        continue;\n      memmove(p, de.name, DIRSIZ);\n      p[DIRSIZ] = 0;\n      if(stat(buf, &st) < 0){\n        printf(\"ls: cannot stat %s\\n\", buf);\n        continue;\n      }\n      printf(\"%s %d %d %d\\n\", fmtname(buf), st.type, st.ino, st.size);\n    }\n    break;\n  }\n  close(fd);\n}\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n\n  if(argc < 2){\n    ls(\".\");\n    exit(0);\n  }\n  for(i=1; i<argc; i++)\n    ls(argv[i]);\n  exit(0);\n}\n```\n\n上面是ls.c的内容，从main开始看，首先是判断输入指令的长度，如果是1的话就将当前目录的内容全部输出，如果不是1的话就进行查找对比，随后进入ls函数，ls函数开始的一堆东西不用管，只需要看switch的两个分枝，这里switch的作用是将文件和文件夹进行区分，这也是我们要的，如果st.type是T_FILE的话就证明是一个文件，将他和我们输入的字符串进行比较，如果相匹配的话就输出（但是ls这里是直接将文件名和各种信息输出了），然后我们看T_DIR部分，虽然这部分有些难看懂，但是实际上我们只需要找到ls输出内容的地方就可以了，直接将printf修改为递归，递归的参数中path已经被拷贝到了buf中，所以参数值写buf和file，让他去递归寻找我们的file，剩下的就是写一个比较函数了。\n\n```\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nint\ncontest(char* path,char* file){\n\tchar *p,*f;\n\tf=file;\n\tfor(p=path+strlen(path);p>=path&&*p!='/';p--)\n\t\t;\n\tp++;\n\tfor(;*p!=0&&*f!=0;p++,f++){\n\t\tif(*p!=*f)\n\t\t\treturn 1;\n\t}\n\tif(*p!=0||*f!=0)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid\nfind(char* path,char* file){\n\tint fd;\n\tchar buf[512],*p;\n\tstruct dirent de;\n\tstruct stat st;\n\tif((fd=open(path,0))<0){\n\t\tfprintf(2,\"find:cannot open %s\\n\",path);\n\t\treturn;\n\t}\n\tif(fstat(fd,&st)<0){\n\t\tfprintf(2,\"find:cannot stat %s\\n\",path);\n\t\tclose(fd);\n\t\treturn;\n\t}\n\tswitch(st.type){\n\t\tcase T_FILE:\n\t\t\tif(contest(path,file)==0)\n\t\t\t\tprintf(\"%s\\n\",path);\n\t\t\tbreak;\n\t\tcase T_DIR:\n\t\t\tif(strlen(path)+1+DIRSIZ+1>sizeof buf){\n\t\t\t\tprintf(\"find:path too long\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrcpy(buf,path);\n\t\t\tp=buf+strlen(buf);\n\t\t\t*p++='/';\n\t\t\twhile(read(fd,&de,sizeof(de))==sizeof(de)){\n\t\t\t\tif(de.inum==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(strcmp(de.name,\".\")==0||strcmp(de.name,\"..\")==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tmemmove(p,de.name,DIRSIZ);\n\t\t\t\tp[DIRSIZ]=0;\n\t\t\t\tfind(buf,file);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\tclose(fd);\n}\n\nint\nmain(int argc, char *argv[]){\n\tif(argc!=3){\n\t\tprintf(\"erro!\\n\");\n\t\texit(0);\n\t}\n\tfind(argv[1],argv[2]);\n\texit(0);\n}\n```\n\ncontest函数是用来比较当前文件和要寻找的文件是否一致的，如果一致的话就返回0，不一致就返回1，然后我们再来看ls中的fmtname函数，在函数的第一个for循环中有一条注释，翻译过来就是“找到最后一个斜杠后的第一个字符”，经过了这个for循环之后p就会指向第一个字符，而f也指向第一个字符，到了这里，p就变成了读取的列表中的文件名，f就变成了我们要找的文件名，所以再写一个for循环将他们一一进行对比，如果发现不一致的地方就返回1，如果for结束了还没有返回，就检查一下是不是两个指针都指向了最后，如果有一个没有指向最后，那就证明还是不匹配，接着返回1，如果都指向了最后，就说明两个是匹配的，返回0。\n\n在实验中提到了strcmp函数，但是这个函数在比较buf和f时并不会输出0，我现在暂且不知为何，所以改了改代码直接一个一个的比较了。\n\n![avator](http://cnd.jiangkeer.icu/pingpong.png)\n\n## Xargs(moderate)\n\n这次实验要求我们复现xargs指令，这个指令的大致作用是在管道中，将输入的部分放到自己的后面执行，大致例子可以在实验中看到，当输入echo hello|xargs echo bye的时候，会先输出bye再输出hello。\n\n首先要知道一件事，就是xargs是用在管道的读端的，而上一条指令的结果是会写入管道的，所以我们可以直接read出上一条指令，并且再将指令拼接的自己的argv中，随后再将拼接好的字符串传到exec中执行，就实现了一个简易的xargs指令。\n\n```\n#include \"kernel/types.h\"\n#include \"user/user.h\"\n#include \"kernel/param.h\"\n#include \"kernel/stat.h\"\n\nint\nmain(int argc,char* argv[]){\n\tchar buf[32];\n\tint n;\n\tif(argc<2){\n\t\twhile((n=read(0,buf,sizeof buf))>0){\n\t\t\twrite(1,buf,n);\n\t\t}\n\t\texit(0);\n\t}\n\tchar* argvv[MAXARG];\n\tint argcc=argc-1;\n\tfor(int i=1;i<argc;++i){\n\t\targvv[i-1]=argv[i];\n\t}\n\tchar *p=buf;\n\twhile((n=read(0,p,1))>0){\n\t\tif(*p=='\\n'){\n\t\t\t*p=0;\n\t\t\tif(fork()==0){\n\t\t\t\targvv[argcc]=buf;\n\t\t\t\texec(argvv[0],argvv);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\twait(0);\n\t\t\t}\n\t\t\tp=buf;\n\t\t}\n\t\telse{\n\t\t\tp++;\n\t\t}\n\t}\n\texit(0);\n}\n```\n\n这里读取字符串是通过while来进行的，每次只读一个字节，当读取到\\n时就证明读完了一个结果，随后进行字符串的拼接，之后放到exec函数中去执行，因为判断条件是*p==\\n所以要将\\n去掉，所以这里将\\n变成了结束符号0，p=buf是将p指向buf的头，之后读的时候新的结果就会将老的结果覆盖掉。","tags":["MIT","操作系统","编成"],"categories":["MIT实验"]}]